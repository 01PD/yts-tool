<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>YouTube 채널 분석 툴 v1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b1120;
      --bg-alt: #020617;
      --card: #020617;
      --accent: #38bdf8;
      --accent-soft: rgba(56,189,248,0.15);
      --border: #1f2937;
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --danger: #f97373;
      --radius-lg: 18px;
      --shadow-soft: 0 18px 40px rgba(0,0,0,0.45);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1e293b 0, #020617 45%, #000 100%);
      color: var(--text);
      overflow-x: hidden;
    }

    .app {
      max-width: 1400px;
      margin: 0 auto;
      padding: 16px 16px 32px;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      gap: 10px;
      margin-bottom: 10px;
    }

    header h1 {
      font-size: 1.4rem;
      margin: 0;
      font-weight: 700;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    header h1 span.badge {
      font-size: 0.7rem;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      color: var(--text-soft);
    }

    header p {
      margin: 0;
      font-size: 0.82rem;
      color: var(--text-soft);
    }

    /* ===== 3단 레이아웃 ===== */
    .main-layout {
      display: grid;
      grid-template-columns: minmax(180px, 1fr) minmax(0, 4fr) minmax(220px, 1fr);
      gap: 12px;
      min-height: calc(100vh - 80px);
    }

    .panel {
      display: flex;
      flex-direction: column;
    }

    .panel-inner {
      background: radial-gradient(circle at top left, #020617 0, #020617 20%, #020617 55%, #000 100%);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(148,163,184,0.15);
      box-shadow: var(--shadow-soft);
      padding: 12px 12px 14px;
      display: flex;
      flex-direction: column;
      height: 100%;
      min-height: 260px;
    }

    .panel-title-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 8px;
    }

    .panel-title-row h2 {
      margin: 0;
      font-size: 0.95rem;
    }

    .panel-title-row span {
      font-size: 0.76rem;
      color: var(--text-soft);
    }

    @media (max-width: 1000px) {
      .main-layout {
        grid-template-columns: 1fr;
      }
      .panel-inner {
        min-height: auto;
      }
    }

    /* ===== 폼 / 컨트롤 ===== */
    .controls-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      align-items: flex-start;
      margin-bottom: 6px;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.78rem;
    }

    .field label {
      color: var(--text-soft);
    }

    .input, select {
      padding: 7px 9px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.8);
      color: var(--text);
      font-size: 0.86rem;
      outline: none;
    }

    .input:focus, select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.3);
    }

    .input::placeholder {
      color: #6b7280;
    }

    .help-text {
      font-size: 0.72rem;
      color: var(--text-soft);
    }

    .mode-toggle {
      display: flex;
      gap: 6px;
      font-size: 0.72rem;
    }

    .mode-button {
      flex: 1;
      padding: 5px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.7);
      color: var(--text-soft);
      cursor: pointer;
    }

    .mode-button.active {
      border-color: var(--accent);
      background: var(--accent-soft);
      color: var(--accent);
    }

    .btn-primary {
      padding: 8px 12px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 0.86rem;
      font-weight: 600;
      background: linear-gradient(135deg, #38bdf8, #22c55e);
      color: #0b1120;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      white-space: nowrap;
    }

    .btn-secondary {
      padding: 6px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      cursor: pointer;
      font-size: 0.78rem;
      background: rgba(15,23,42,0.7);
      color: var(--text-soft);
      white-space: nowrap;
    }

    .btn-secondary.small {
      padding: 3px 8px;
      font-size: 0.75rem;
    }

    .btn-primary:disabled,
    .btn-secondary:disabled {
      opacity: 0.4;
      cursor: default;
    }

    .controls-actions {
      display: flex;
      gap: 6px;
      justify-content: flex-end;
      align-items: center;
      margin-top: 4px;
      flex-wrap: wrap;
    }

    .status-bar {
      margin-top: 6px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.76rem;
      color: var(--text-soft);
    }

    .status-message {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .status-message.danger {
      color: var(--danger);
    }

    .status-message.loading-dot::after {
      content: " •";
      animation: dots 1s infinite steps(3, end);
    }

    @keyframes dots {
      0%, 20% { content: " •"; }
      40% { content: " ••"; }
      60%, 100% { content: " •••"; }
    }

    .pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.35);
      font-size: 0.74rem;
      color: var(--text-soft);
      align-self: flex-end;
    }

    .pill strong {
      color: var(--accent);
      font-weight: 600;
    }

    .range-row {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .range-row input {
      flex: 1;
    }

    .range-row span {
      font-size: 0.75rem;
      color: var(--text-soft);
    }

    .checkbox-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.76rem;
    }

    .checkbox-row label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }

    .checkbox-row input {
      accent-color: var(--accent);
    }

    /* ===== 결과 리스트 ===== */
    .results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    .results-header h2 {
      margin: 0;
      font-size: 0.95rem;
    }

    .results-toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.78rem;
      flex-wrap: wrap;
    }

    .results-toolbar label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .results-toolbar select {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
      color: var(--text-soft);
      font-size: 0.78rem;
    }

    .sort-dir-btn {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
      color: var(--text-soft);
      font-size: 0.76rem;
      cursor: pointer;
    }

    .sort-dir-btn.active {
      border-color: var(--accent);
      background: var(--accent-soft);
      color: var(--accent);
    }

    .results-toolbar span#resultsInfo {
      color: var(--text-soft);
    }

    .results-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding-right: 2px;
      flex: 1;
      max-height: calc(100vh - 170px);
      overflow-y: auto;
      overflow-x: hidden;
    }

    .video-card {
      display: grid;
      grid-template-columns: 260px minmax(0, 1fr);
      gap: 12px;
      background: rgba(15,23,42,0.9);
      border-radius: 14px;
      border: 1px solid rgba(55,65,81,0.7);
      overflow: hidden;
      min-height: 150px;
    }

    @media (max-width: 900px) {
      .video-card {
        grid-template-columns: 1fr;
      }
    }

    .video-thumb {
      position: relative;
      overflow: hidden;
      aspect-ratio: 16 / 9;
    }

    .video-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .video-duration {
      position: absolute;
      right: 6px;
      bottom: 6px;
      font-size: 0.72rem;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(0,0,0,0.75);
      color: #f9fafb;
    }

    .video-body {
      padding: 8px 10px 9px 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .video-title {
      font-size: 0.9rem;
      font-weight: 600;
      line-height: 1.3;
    }

    .video-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 0.75rem;
      color: var(--text-soft);
    }

    .video-meta span {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    /* 메타 색상 */
    .meta-date {
      color: #fb923c;  /* 주황 */
    }
    .meta-views {
      color: #facc15;  /* 노랑 */
    }
    .meta-subs {
      color: #38bdf8;  /* 하늘색 */
    }
    .meta-vph {
      color: #22c55e;  /* 초록색 */
    }

    .video-link {
      margin-top: 4px;
      font-size: 0.76rem;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .video-link a {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.95);
      color: var(--accent);
      text-decoration: none;
    }

    .video-link a.primary {
      background: var(--accent-soft);
    }

    .video-link a:hover {
      text-decoration: underline;
    }

    /* ===== 채널 후보 카드 ===== */
    .channel-card {
      display: grid;
      grid-template-columns: 80px minmax(0, 1fr);
      gap: 12px;
      background: rgba(15,23,42,0.9);
      border-radius: 14px;
      border: 1px solid rgba(55,65,81,0.7);
      padding: 8px;
      cursor: pointer;
    }

    .channel-card:hover {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.3);
    }

    .channel-thumb {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .channel-thumb img {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      object-fit: cover;
    }

    .channel-body .channel-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .channel-body .channel-id {
      font-size: 0.76rem;
      color: var(--text-soft);
    }

    .channel-body .channel-hint {
      font-size: 0.74rem;
      color: var(--accent);
      margin-top: 4px;
    }

    /* ===== 좌측 요약 분석 ===== */
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
      font-size: 0.8rem;
      margin-bottom: 6px;
    }

    .stat-item {
      padding: 6px 7px;
      border-radius: 10px;
      background: rgba(15,23,42,0.95);
      border: 1px solid rgba(31,41,55,0.9);
    }

    .stat-label {
      font-size: 0.72rem;
      color: var(--text-soft);
      margin-bottom: 1px;
    }

    .stat-value {
      font-size: 0.88rem;
      font-weight: 600;
    }

    .analysis-block {
      margin-top: 6px;
    }

    .analysis-block h3 {
      margin: 0 0 4px;
      font-size: 0.86rem;
    }

    .keyword-list {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      font-size: 0.76rem;
      max-height: 90px;
      overflow: auto;
    }

    .keyword-chip {
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(15,23,42,0.95);
      border: 1px solid rgba(55,65,81,0.8);
    }

    .keyword-chip span.count {
      color: var(--accent);
      margin-left: 4px;
    }

    .analysis-header {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      margin-bottom: 4px;
      gap: 6px;
    }

    .analysis-content {
      max-height: 180px;
      overflow-y: auto;
      font-size: 0.78rem;
      background: rgba(15,23,42,0.95);
      border-radius: 10px;
      border: 1px solid rgba(31,41,55,0.9);
      padding: 6px 8px;
      white-space: pre-wrap;
      line-height: 1.4;
    }

    .copy-btn {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.6);
      background: rgba(15,23,42,0.9);
      color: var(--text-soft);
      font-size: 0.76rem;
      cursor: pointer;
    }

    .copy-btn:disabled {
      opacity: 0.4;
      cursor: default;
    }

    .empty-state {
      font-size: 0.78rem;
      color: var(--text-soft);
      padding: 8px 0;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>
        YouTube 채널 분석 툴
        <span class="badge">v1 · HTML Only</span>
      </h1>
      <p>채널·영상 메타데이터를 브라우저에서 바로 분석합니다.</p>
    </header>

    <section class="main-layout">
      <!-- 좌측 요약 분석 -->
      <aside class="panel">
        <div class="panel-inner">
          <div class="panel-title-row">
            <h2>요약 분석</h2>
            <span>기본 통계 & 제목 키워드</span>
          </div>

          <div id="statsContainer" class="stats-grid">
            <div class="stat-item">
              <div class="stat-label">총 조회수 합계</div>
              <div class="stat-value" id="statTotalViews">-</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">영상 1개당 평균 조회수</div>
              <div class="stat-value" id="statAvgViews">-</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">평균 VPH (조회수/업로드 후 시간)</div>
              <div class="stat-value" id="statAvgVph">-</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">평균 길이 (분)</div>
              <div class="stat-value" id="statAvgDuration">-</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">평균 제목 글자 수</div>
              <div class="stat-value" id="statAvgTitleLen">-</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">가장 최근 업로드</div>
              <div class="stat-value" id="statLatest">-</div>
            </div>
          </div>

          <div class="analysis-block">
            <h3>제목 키워드 TOP 15</h3>
            <div id="keywordList" class="keyword-list">
              <span class="empty-state">
                제목 데이터를 불러오면 여기에서 많이 쓰인 단어들을 보여줍니다.
              </span>
            </div>
          </div>

          <div class="analysis-block">
            <h3>분석 결과</h3>
            <div class="analysis-header">
              <button type="button" id="copyAnalysisBtn" class="copy-btn" disabled>
                분석 내용 복사
              </button>
            </div>
            <div id="analysisContent" class="analysis-content">
              <div class="help-text">
                아직 분석된 영상이 없습니다. 가운데 목록의 영상 카드에서
                <strong>「분석」 버튼</strong>을 누르면 여기 결과가 표시됩니다.
              </div>
            </div>
          </div>
        </div>
      </aside>

      <!-- 가운데 결과 리스트 -->
      <main class="panel">
        <div class="panel-inner">
          <div class="results-header">
            <h2>영상 / 채널 목록</h2>
            <div class="results-toolbar">
              <label for="resultSortField">
                <span>정렬 기준</span>
                <select id="resultSortField">
                  <option value="views">조회수</option>
                  <option value="date">게시일</option>
                  <option value="subs">구독자</option>
                  <option value="vph">VPH</option>
                </select>
              </label>
              <button type="button" class="sort-dir-btn active" data-dir="desc">높은 순</button>
              <button type="button" class="sort-dir-btn" data-dir="asc">낮은 순</button>
              <span id="resultsInfo">아직 불러온 데이터가 없습니다.</span>
            </div>
          </div>
          <div id="resultsList" class="results-list">
            <div class="empty-state">
              이 영역에 분석 대상 영상 카드 또는 채널 후보 카드가 표시됩니다.
            </div>
          </div>
        </div>
      </main>

      <!-- 우측 검색/필터 -->
      <aside class="panel">
        <div class="panel-inner">
          <div class="panel-title-row">
            <h2>검색 & 필터</h2>
            <span style="font-size:0.74rem;">우측 패널에서 조건 설정</span>
          </div>

          <div class="controls-grid">
            <div class="field">
              <label for="apiKey">YouTube API 키 <span style="color:#f97373">*</span></label>
              <input
                id="apiKey"
                class="input"
                type="password"
                placeholder="브라우저 키를 여기 입력 (코드에 직접 넣지 마세요)"
              />
              <div class="help-text">
                Google Cloud에서 얻은 <strong>API 키</strong>를 입력하세요.
              </div>
            </div>

            <div class="field">
              <label>검색 모드</label>
              <div class="mode-toggle">
                <button type="button" class="mode-button active" data-mode="channel">
                  채널 기준
                </button>
                <button type="button" class="mode-button" data-mode="keyword">
                  키워드 / 링크
                </button>
              </div>
              <div class="help-text">
                채널(링크/ID/이름) 기준 분석 또는 키워드/영상링크 기준 분석 중 선택.
              </div>
            </div>

            <div class="field" id="channelField">
              <label for="channelId">채널 입력</label>
              <input
                id="channelId"
                class="input"
                type="text"
                placeholder="채널 URL, ID(UC...), @핸들, 또는 채널 이름(예: 사연그네)"
              />
              <div class="help-text">
                예시: <br />
                · <code>https://www.youtube.com/@sayongeune</code><br />
                · <code>https://www.youtube.com/channel/UCxxxx</code><br />
                · <code>@sayongeune</code> 또는 <code>UCxxxx...</code><br />
                · <code>사연그네</code> (채널 이름으로 검색)
              </div>
            </div>

            <div class="field" id="keywordField" style="display:none;">
              <label for="keyword">키워드 / 영상 URL</label>
              <input
                id="keyword"
                class="input"
                type="text"
                placeholder="키워드 또는 영상 링크 (예: https://youtu.be/...)"
              />
              <div class="help-text">
                키워드 또는 <strong>영상 URL</strong>을 넣으면 그 영상만 단독 분석 가능.
              </div>
            </div>

            <div class="field">
              <label for="order">API 정렬 기준</label>
              <select id="order">
                <option value="date">최신순</option>
                <option value="viewCount">조회수 순</option>
                <option value="relevance">관련도 순 (키워드 사용 시)</option>
              </select>
              <div class="help-text">YouTube Data API 기본 정렬 기준.</div>
            </div>

            <div class="field">
              <label for="maxResults">최대 영상 개수 (1~150)</label>
              <input
                id="maxResults"
                class="input"
                type="number"
                min="1"
                max="150"
                value="50"
              />
              <div class="help-text">페이지네이션을 돌리며 최대 이 숫자까지 가져옵니다.</div>
            </div>

            <div class="field">
              <label for="daysRange">최근 N일 이내 업로드만</label>
              <input
                id="daysRange"
                class="input"
                type="number"
                min="0"
                value="0"
              />
              <div class="help-text">0이면 기간 제한 없음.</div>
            </div>

            <div class="field">
              <label>조회수 범위</label>
              <div class="range-row">
                <input id="minViews" class="input" type="number" min="0" value="10000" />
                <span>~</span>
                <input id="maxViews" class="input" type="number" min="0" placeholder="무제한" />
              </div>
            </div>

            <div class="field">
              <label>구독자 수 범위 (채널)</label>
              <div class="range-row">
                <input id="minSubs" class="input" type="number" min="0" value="0" />
                <span>~</span>
                <input id="maxSubs" class="input" type="number" min="0" value="10000" />
              </div>
            </div>

            <div class="field">
              <label>타입 필터</label>
              <div class="checkbox-row">
                <label>
                  <input type="checkbox" id="excludeLive" />
                  <span>라이브 제외</span>
                </label>
                <label>
                  <input type="checkbox" id="excludeShorts" />
                  <span>숏폼 제외 (&lt; 60초)</span>
                </label>
              </div>
            </div>
          </div>

          <div class="controls-actions">
            <button type="button" class="btn-secondary" id="exportCsvBtn" disabled>
              CSV 다운로드
            </button>
            <button type="button" class="btn-primary" id="fetchBtn">
              불러오기 & 분석
            </button>
          </div>

          <div class="status-bar">
            <div class="status-message" id="statusMessage">
              준비 완료. API 키와 조건을 입력하고 실행하세요.
            </div>
            <div class="pill" id="statusSummary">
              <span>분석된 영상: <strong>0</strong>개</span>
            </div>
          </div>
        </div>
      </aside>
    </section>
  </div>

  <script>
    // ===== 전역 상태 =====
    let currentMode = "channel";
    let allVideos = [];
    let currentVideos = [];
    let sortDirection = "desc"; // desc=높은순, asc=낮은순
    let lastAnalysisText = "";

    // ===== DOM 참조 =====
    const modeButtons = document.querySelectorAll(".mode-button");
    const channelField = document.getElementById("channelField");
    const keywordField = document.getElementById("keywordField");

    const apiKeyInput = document.getElementById("apiKey");
    const channelIdInput = document.getElementById("channelId");
    const keywordInput = document.getElementById("keyword");
    const orderSelect = document.getElementById("order");
    const maxResultsInput = document.getElementById("maxResults");
    const daysRangeInput = document.getElementById("daysRange");

    const minViewsInput = document.getElementById("minViews");
    const maxViewsInput = document.getElementById("maxViews");
    const minSubsInput = document.getElementById("minSubs");
    const maxSubsInput = document.getElementById("maxSubs");
    const excludeLiveInput = document.getElementById("excludeLive");
    const excludeShortsInput = document.getElementById("excludeShorts");

    const sortFieldSelect = document.getElementById("resultSortField");
    const sortDirButtons = document.querySelectorAll(".sort-dir-btn");

    const fetchBtn = document.getElementById("fetchBtn");
    const exportCsvBtn = document.getElementById("exportCsvBtn");

    const statusMessageEl = document.getElementById("statusMessage");
    const statusSummaryEl = document.getElementById("statusSummary");
    const resultsInfoEl = document.getElementById("resultsInfo");
    const resultsListEl = document.getElementById("resultsList");

    const statTotalViewsEl = document.getElementById("statTotalViews");
    const statAvgViewsEl = document.getElementById("statAvgViews");
    const statAvgVphEl = document.getElementById("statAvgVph");
    const statAvgDurationEl = document.getElementById("statAvgDuration");
    const statAvgTitleLenEl = document.getElementById("statAvgTitleLen");
    const statLatestEl = document.getElementById("statLatest");
    const keywordListEl = document.getElementById("keywordList");

    const analysisContentEl = document.getElementById("analysisContent");
    const copyAnalysisBtn = document.getElementById("copyAnalysisBtn");

    // ===== 공통 유틸 =====
    function setStatus(message, type = "info", loading = false) {
      statusMessageEl.textContent = message;
      statusMessageEl.classList.toggle("danger", type === "error");
      statusMessageEl.classList.toggle("loading-dot", loading);
    }

    function updateSummaryCount(count) {
      statusSummaryEl.innerHTML = '분석된 영상: <strong>' + count + "</strong>개";
    }

    function formatNumber(num) {
      if (num === null || num === undefined || isNaN(num)) return "-";
      return Number(num).toLocaleString("ko-KR");
    }

    function formatDate(dateStr) {
      const d = new Date(dateStr);
      if (isNaN(d.getTime())) return "-";
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return y + "." + m + "." + day;
    }

    function timeSinceUpload(dateStr) {
      const now = Date.now();
      const t = new Date(dateStr).getTime();
      if (isNaN(t)) return "-";
      const diffMs = now - t;
      const diffDays = diffMs / (1000 * 60 * 60 * 24);
      if (diffDays < 1) {
        const hours = diffMs / (1000 * 60 * 60);
        return hours.toFixed(1) + "시간 전";
      }
      if (diffDays < 30) return Math.floor(diffDays) + "일 전";
      const months = diffDays / 30;
      if (months < 12) return Math.floor(months) + "개월 전";
      const years = diffDays / 365;
      return Math.floor(years) + "년 전";
    }

    function isoDurationToSeconds(iso) {
      if (!iso || typeof iso !== "string") return 0;
      const match = iso.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
      if (!match) return 0;
      const hours = parseInt(match[1] || "0", 10);
      const minutes = parseInt(match[2] || "0", 10);
      const seconds = parseInt(match[3] || "0", 10);
      return hours * 3600 + minutes * 60 + seconds;
    }

    function formatSecondsToHMS(totalSeconds) {
      if (!totalSeconds || isNaN(totalSeconds)) return "00:00";
      const h = Math.floor(totalSeconds / 3600);
      const m = Math.floor((totalSeconds % 3600) / 60);
      const s = totalSeconds % 60;
      if (h > 0) {
        return [h, m.toString().padStart(2, "0"), s.toString().padStart(2, "0")].join(":");
      }
      return [m, s.toString().padStart(2, "0")]
        .map((v) => v.toString().padStart(2, "0"))
        .join(":");
    }

    function tokenizeTitle(title) {
      if (!title) return [];
      const cleaned = title
        .replace(/[^\p{L}\p{N}\s]/gu, " ")
        .replace(/\s+/g, " ")
        .trim();
      if (!cleaned) return [];
      const tokens = cleaned.split(" ");
      return tokens.filter((t) => t.length > 1);
    }

    function extractVideoIdFromInput(raw) {
      const input = raw.trim();
      if (!input) return null;
      if (/^[0-9A-Za-z_-]{11}$/.test(input)) return input;
      if (!input.startsWith("http")) return null;
      try {
        const u = new URL(input);
        const host = u.hostname.replace(/^www\./, "");
        const pathParts = u.pathname.split("/").filter(Boolean);

        const vParam = u.searchParams.get("v");
        if (vParam && /^[0-9A-Za-z_-]{11}$/.test(vParam)) return vParam;

        if (host === "youtu.be" && pathParts[0] && /^[0-9A-Za-z_-]{11}$/.test(pathParts[0])) {
          return pathParts[0];
        }

        const idx = pathParts.findIndex((p) => p === "shorts" || p === "embed");
        if (idx >= 0 && pathParts[idx + 1] && /^[0-9A-Za-z_-]{11}$/.test(pathParts[idx + 1])) {
          return pathParts[idx + 1];
        }
      } catch {
        return null;
      }
      return null;
    }

    // ===== 채널 입력 해석 =====
    async function resolveChannelFromInput(apiKey, rawInput) {
      const input = rawInput.trim();
      if (!input) throw new Error("채널 입력이 비어 있습니다.");

      // UC... 형식
      if (/^UC[0-9A-Za-z_-]{20,}$/.test(input)) {
        return { type: "id", id: input };
      }

      let handle = null;
      let channelId = null;
      let nameQuery = null;

      if (input.startsWith("http")) {
        try {
          const u = new URL(input);
          const host = u.hostname.replace(/^www\./, "");
          const parts = u.pathname.split("/").filter(Boolean);

          if (host.includes("youtube")) {
            if (parts[0] === "channel" && parts[1]) {
              channelId = parts[1];
            } else if (parts[0] && parts[0].startsWith("@")) {
              handle = "@" + parts[0].replace(/^@/, "");
            } else if ((parts[0] === "c" || parts[0] === "user") && parts[1]) {
              nameQuery = decodeURIComponent(parts[1]);
            }
          }
        } catch {
          // ignore
        }
      }

      if (!handle && input.startsWith("@")) handle = input;

      if (channelId) return { type: "id", id: channelId };

      if (handle) {
        const handleClean = handle.replace(/^@/, "");
        const params = new URLSearchParams({
          key: apiKey,
          part: "snippet",
          forHandle: handleClean
        });
        const url = "https://www.googleapis.com/youtube/v3/channels?" + params.toString();
        const res = await fetch(url);
        if (!res.ok) throw new Error("채널 핸들 조회 실패 (HTTP " + res.status + ")");
        const data = await res.json();
        if (data.items && data.items.length > 0) {
          return { type: "id", id: data.items[0].id };
        }
        throw new Error("해당 핸들의 채널을 찾을 수 없습니다.");
      }

      // 이름 검색
      nameQuery = nameQuery || input;
      const searchParams = new URLSearchParams({
        key: apiKey,
        part: "snippet",
        q: nameQuery,
        type: "channel",
        maxResults: "25"
      });
      const url = "https://www.googleapis.com/youtube/v3/search?" + searchParams.toString();
      const res = await fetch(url);
      if (!res.ok) {
        const errData = await res.json().catch(() => ({}));
        const msg =
          errData.error && errData.error.message
            ? errData.error.message
            : "채널 이름 검색 실패 (HTTP " + res.status + ")";
        throw new Error(msg);
      }
      const data = await res.json();
      const items = data.items || [];
      if (!items.length) throw new Error("해당 이름의 채널을 찾을 수 없습니다.");

      const trimmed = nameQuery.trim();
      const exactMatches = items.filter(
        (it) =>
          it.snippet &&
          it.snippet.title &&
          it.snippet.title.trim() === trimmed
      );

      const toChannelObj = (it) => {
        const sn = it.snippet || {};
        const thumbs = sn.thumbnails || {};
        const thumbObj = thumbs.medium || thumbs.default || null;
        return {
          id: it.id.channelId,
          title: sn.title || "",
          description: sn.description || "",
          thumbnail: thumbObj
        };
      };

      if (exactMatches.length === 1) {
        return { type: "id", id: exactMatches[0].id.channelId };
      }

      if (exactMatches.length > 1) {
        return { type: "multi", channels: exactMatches.map(toChannelObj) };
      }

      const channels = items.map(toChannelObj);
      if (channels.length === 1) return { type: "id", id: channels[0].id };
      return { type: "multi", channels };
    }

    // ===== 채널 구독자 수 붙이기 =====
    async function attachChannelSubs(apiKey, videos) {
      const channelIds = Array.from(
        new Set(
          videos
            .map((v) => (v.snippet && v.snippet.channelId) || null)
            .filter(Boolean)
        )
      );
      if (!channelIds.length) return;
      const subsMap = {};

      for (let i = 0; i < channelIds.length; i += 50) {
        const batch = channelIds.slice(i, i + 50);
        const params = new URLSearchParams({
          key: apiKey,
          part: "statistics",
          id: batch.join(",")
        });
        const url = "https://www.googleapis.com/youtube/v3/channels?" + params.toString();
        const res = await fetch(url);
        if (!res.ok) {
          console.warn("channels.list 실패", res.status);
          return;
        }
        const data = await res.json();
        (data.items || []).forEach((ch) => {
          const stats = ch.statistics || {};
          subsMap[ch.id] = Number(stats.subscriberCount || 0);
        });
      }

      videos.forEach((v) => {
        const cid = v.snippet && v.snippet.channelId;
        v._subscriberCount = subsMap[cid] != null ? subsMap[cid] : 0;
      });
    }

    function calcVph(video) {
      const stats = video.statistics || {};
      const snippet = video.snippet || {};
      const views = Number(stats.viewCount || 0);
      const publishedAt = snippet.publishedAt || "";
      const t = new Date(publishedAt).getTime();
      if (isNaN(t)) return 0;
      const diffHours = (Date.now() - t) / (1000 * 60 * 60);
      if (diffHours <= 0) return 0;
      return views / diffHours;
    }

    function setAnalysisText(text) {
      lastAnalysisText = text || "";
      if (!text) {
        analysisContentEl.innerHTML =
          '<div class="help-text">분석된 내용이 없습니다. 가운데 카드의 「분석」 버튼을 눌러주세요.</div>';
        copyAnalysisBtn.disabled = true;
      } else {
        analysisContentEl.textContent = text;
        copyAnalysisBtn.disabled = false;
      }
    }

    // ===== 필터 & 정렬 =====
    function applyFiltersAndSort() {
      if (!allVideos.length) {
        currentVideos = [];
        renderVideos();
        computeStats();
        resultsInfoEl.textContent = "0개의 영상";
        updateSummaryCount(0);
        exportCsvBtn.disabled = true;
        return;
      }

      let minViews = parseInt(minViewsInput.value || "0", 10);
      if (isNaN(minViews) || minViews < 0) minViews = 0;

      let maxViews = parseInt(maxViewsInput.value || "", 10);
      if (isNaN(maxViews) || maxViews <= 0) maxViews = Infinity;

      let minSubs = parseInt(minSubsInput.value || "0", 10);
      if (isNaN(minSubs) || minSubs < 0) minSubs = 0;

      let maxSubs = parseInt(maxSubsInput.value || "", 10);
      if (isNaN(maxSubs) || maxSubs <= 0) maxSubs = Infinity;

      const excludeLive = !!excludeLiveInput.checked;
      const excludeShorts = !!excludeShortsInput.checked;

      let filtered = allVideos.filter((video) => {
        const snippet = video.snippet || {};
        const stats = video.statistics || {};
        const content = video.contentDetails || {};
        const views = Number(stats.viewCount || 0);
        const subs = Number(video._subscriberCount || 0);
        const durationSeconds = isoDurationToSeconds(content.duration || "");

        if (views < minViews || views > maxViews) return false;
        if (subs < minSubs || subs > maxSubs) return false;

        if (excludeLive) {
          const lbc = snippet.liveBroadcastContent;
          if (lbc && lbc !== "none") return false;
        }

        if (excludeShorts) {
          if (durationSeconds > 0 && durationSeconds < 60) return false;
        }

        return true;
      });

      const field = sortFieldSelect.value; // views/date/subs/vph
      const dir = sortDirection === "asc" ? 1 : -1;

      filtered.sort((a, b) => {
        let ka = 0, kb = 0;
        if (field === "views") {
          ka = Number(a.statistics && a.statistics.viewCount || 0);
          kb = Number(b.statistics && b.statistics.viewCount || 0);
        } else if (field === "date") {
          ka = new Date(a.snippet && a.snippet.publishedAt || 0).getTime();
          kb = new Date(b.snippet && b.snippet.publishedAt || 0).getTime();
        } else if (field === "subs") {
          ka = Number(a._subscriberCount || 0);
          kb = Number(b._subscriberCount || 0);
        } else if (field === "vph") {
          ka = calcVph(a);
          kb = calcVph(b);
        }
        return (kb - ka) * dir;
      });

      currentVideos = filtered;
      renderVideos();
      computeStats();
      resultsInfoEl.textContent =
        filtered.length + "개의 영상 (필터·정렬 적용됨)";
      updateSummaryCount(filtered.length);
      exportCsvBtn.disabled = !filtered.length;
    }

    // ===== 메인 fetch =====
    async function fetchVideos() {
      const apiKey = apiKeyInput.value.trim();
      const channelIdRaw = channelIdInput.value.trim();
      const keywordRaw = keywordInput.value.trim();
      const order = orderSelect.value;
      const maxResults = Math.min(
        150,
        Math.max(1, parseInt(maxResultsInput.value || "50", 10))
      );
      const daysRange = Math.max(0, parseInt(daysRangeInput.value || "0", 10));

      if (!apiKey) {
        setStatus("API 키를 입력해주세요.", "error");
        return;
      }
      if (currentMode === "channel" && !channelIdRaw) {
        setStatus("채널 입력을 해주세요. (URL/ID/@/이름)", "error");
        return;
      }
      if (currentMode === "keyword" && !keywordRaw) {
        setStatus("키워드 또는 영상 URL을 입력해주세요.", "error");
        return;
      }

      fetchBtn.disabled = true;
      exportCsvBtn.disabled = true;
      setStatus("YouTube에서 데이터를 불러오는 중입니다...", "info", true);
      resultsListEl.innerHTML = "";
      resultsInfoEl.textContent = "불러오는 중...";
      allVideos = [];
      currentVideos = [];
      updateSummaryCount(0);
      resetStats();
      setAnalysisText("");

      try {
        // 키워드 모드: URL 단일 영상 처리
        if (currentMode === "keyword") {
          const vidId = extractVideoIdFromInput(keywordRaw);
          if (vidId) {
            const videosBase = "https://www.googleapis.com/youtube/v3/videos";
            const params = new URLSearchParams({
              key: apiKey,
              part: "snippet,contentDetails,statistics",
              id: vidId
            });
            const url = videosBase + "?" + params.toString();
            const res = await fetch(url);
            if (!res.ok) {
              const errData = await res.json().catch(() => ({}));
              const msg =
                errData.error && errData.error.message
                  ? errData.error.message
                  : "영상 조회 실패 (HTTP " + res.status + ")";
              throw new Error(msg);
            }
            const data = await res.json();
            const items = data.items || [];
            if (!items.length) throw new Error("해당 영상 ID/URL로 영상을 찾을 수 없습니다.");

            await attachChannelSubs(apiKey, items).catch(() => {});
            allVideos = items;
            applyFiltersAndSort();
            setStatus("단일 영상 분석 완료.", "info");
            return;
          }
        }

        // 채널 모드: 채널 해석
        let channelIdForSearch = null;
        let channelCandidates = null;

        if (currentMode === "channel") {
          const resolution = await resolveChannelFromInput(apiKey, channelIdRaw);
          if (resolution.type === "id") {
            channelIdForSearch = resolution.id;
          } else if (resolution.type === "multi") {
            channelCandidates = resolution.channels || [];
            renderChannelCandidates(channelCandidates);
            setStatus(
              "채널 이름 '" +
                channelIdRaw +
                "'로 " +
                channelCandidates.length +
                "개 채널을 찾았습니다. 카드 클릭 시 해당 채널을 분석합니다.",
              "info"
            );
            resultsInfoEl.textContent = channelCandidates.length + "개 채널 후보";
            fetchBtn.disabled = false;
            return;
          } else {
            throw new Error("채널을 찾을 수 없습니다.");
          }
        }

        // 공통: search API
        const searchBase = "https://www.googleapis.com/youtube/v3/search";
        const searchParams = new URLSearchParams({
          key: apiKey,
          part: "snippet",
          maxResults: "50",
          type: "video",
          order
        });

        if (currentMode === "channel") {
          searchParams.set("channelId", channelIdForSearch);
        } else {
          searchParams.set("q", keywordRaw);
        }

        if (daysRange > 0) {
          const now = new Date();
          const past = new Date(now.getTime() - daysRange * 24 * 60 * 60 * 1000);
          searchParams.set("publishedAfter", past.toISOString());
        }

        let fetched = 0;
        let nextPageToken = null;
        const videoIds = [];

        do {
          if (nextPageToken) {
            searchParams.set("pageToken", nextPageToken);
          } else {
            searchParams.delete("pageToken");
          }
          const url = searchBase + "?" + searchParams.toString();
          const res = await fetch(url);
          if (!res.ok) {
            const errData = await res.json().catch(() => ({}));
            const msg =
              errData.error && errData.error.message
                ? errData.error.message
                : "검색 API 실패 (HTTP " + res.status + ")";
            throw new Error(msg);
          }
          const data = await res.json();
          const items = data.items || [];
          items.forEach((it) => {
            if (it.id && it.id.videoId) videoIds.push(it.id.videoId);
          });

          fetched += items.length;
          nextPageToken = data.nextPageToken && fetched < maxResults ? data.nextPageToken : null;
        } while (nextPageToken && fetched < maxResults);

        if (!videoIds.length) {
          setStatus("조건에 맞는 영상이 없습니다.", "info");
          resultsInfoEl.textContent = "0개의 영상";
          resultsListEl.innerHTML =
            '<div class="empty-state">조건에 맞는 영상이 없거나, 검색 조건이 너무 제한적일 수 있습니다.</div>';
          return;
        }

        const uniqueIds = Array.from(new Set(videoIds)).slice(0, maxResults);
        const detailedVideos = [];
        const videosBase = "https://www.googleapis.com/youtube/v3/videos";

        for (let i = 0; i < uniqueIds.length; i += 50) {
          const batch = uniqueIds.slice(i, i + 50);
          const params = new URLSearchParams({
            key: apiKey,
            part: "snippet,contentDetails,statistics",
            id: batch.join(",")
          });
          const url = videosBase + "?" + params.toString();
          const res = await fetch(url);
          if (!res.ok) {
            const errData = await res.json().catch(() => ({}));
            const msg =
              errData.error && errData.error.message
                ? errData.error.message
                : "videos.list 실패 (HTTP " + res.status + ")";
            throw new Error(msg);
          }
          const data = await res.json();
          (data.items || []).forEach((item) => detailedVideos.push(item));
        }

        await attachChannelSubs(apiKey, detailedVideos).catch(() => {});

        detailedVideos.sort((a, b) => {
          const da = new Date(a.snippet && a.snippet.publishedAt || 0).getTime();
          const db = new Date(b.snippet && b.snippet.publishedAt || 0).getTime();
          return db - da;
        });

        allVideos = detailedVideos;
        applyFiltersAndSort();
        setStatus(
          "불러오기 완료. 총 " + allVideos.length + "개 영상 로드됨.",
          "info"
        );
      } catch (err) {
        console.error(err);
        setStatus("오류: " + err.message, "error");
        resultsInfoEl.textContent = "에러 발생";
        resultsListEl.innerHTML =
          '<div class="empty-state">요청 중 오류가 발생했습니다. API 키, 쿼터, 입력값을 다시 확인해주세요.</div>';
      } finally {
        fetchBtn.disabled = false;
      }
    }

    // ===== 채널 후보 렌더링 =====
    function renderChannelCandidates(channels) {
      allVideos = [];
      currentVideos = [];
      resetStats();
      setAnalysisText("");
      resultsListEl.innerHTML = "";

      if (!channels || !channels.length) {
        resultsListEl.innerHTML =
          '<div class="empty-state">표시할 채널 후보가 없습니다.</div>';
        return;
      }

      const fr = document.createDocumentFragment();
      channels.forEach((ch) => {
        const card = document.createElement("article");
        card.className = "channel-card";

        const thumbDiv = document.createElement("div");
        thumbDiv.className = "channel-thumb";
        if (ch.thumbnail && ch.thumbnail.url) {
          const img = document.createElement("img");
          img.src = ch.thumbnail.url;
          img.alt = ch.title;
          thumbDiv.appendChild(img);
        } else {
          thumbDiv.innerHTML =
            '<div style="width:64px;height:64px;border-radius:50%;border:1px solid #4b5563;display:flex;align-items:center;justify-content:center;font-size:0.8rem;color:#6b7280;">No</div>';
        }

        const bodyDiv = document.createElement("div");
        bodyDiv.className = "channel-body";
        const titleDiv = document.createElement("div");
        titleDiv.className = "channel-title";
        titleDiv.textContent = ch.title;
        const idDiv = document.createElement("div");
        idDiv.className = "channel-id";
        idDiv.textContent = "ID: " + ch.id;
        const hintDiv = document.createElement("div");
        hintDiv.className = "channel-hint";
        hintDiv.textContent = "이 채널을 클릭하면 해당 채널 영상들을 분석합니다.";

        bodyDiv.appendChild(titleDiv);
        bodyDiv.appendChild(idDiv);
        bodyDiv.appendChild(hintDiv);

        card.appendChild(thumbDiv);
        card.appendChild(bodyDiv);

        card.addEventListener("click", () => {
          channelIdInput.value = ch.id;
          fetchVideos();
        });

        fr.appendChild(card);
      });

      resultsListEl.appendChild(fr);
    }

    // ===== 결과 렌더링 (영상 카드) =====
    function renderVideos() {
      if (!currentVideos.length) {
        resultsListEl.innerHTML =
          '<div class="empty-state">표시할 영상이 없습니다. (필터 조건을 조정해보세요.)</div>';
        return;
      }

      const fr = document.createDocumentFragment();

      currentVideos.forEach((video) => {
        const snippet = video.snippet || {};
        const stats = video.statistics || {};
        const content = video.contentDetails || {};
        const vid = video.id;
        const title = snippet.title || "";
        const publishedAt = snippet.publishedAt || "";
        const thumbs = snippet.thumbnails || {};
        const thumbObj = thumbs.medium || thumbs.default || null;
        const thumbUrl = thumbObj && thumbObj.url ? thumbObj.url : null;
        const durationSeconds = isoDurationToSeconds(content.duration);
        const views = Number(stats.viewCount || 0);
        const likes = Number(stats.likeCount || 0);
        const comments = Number(stats.commentCount || 0);
        const subs = Number(video._subscriberCount || 0);
        const vph = calcVph(video);

        const card = document.createElement("article");
        card.className = "video-card";

        const thumbDiv = document.createElement("div");
        thumbDiv.className = "video-thumb";
        if (thumbUrl) {
          const img = document.createElement("img");
          img.src = thumbUrl;
          img.alt = title;
          thumbDiv.appendChild(img);
        } else {
          thumbDiv.innerHTML =
            '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:0.8rem;color:#6b7280;">No Thumbnail</div>';
        }
        const durBadge = document.createElement("div");
        durBadge.className = "video-duration";
        durBadge.textContent = formatSecondsToHMS(durationSeconds);
        thumbDiv.appendChild(durBadge);

        const bodyDiv = document.createElement("div");
        bodyDiv.className = "video-body";

        const titleDiv = document.createElement("div");
        titleDiv.className = "video-title";
        titleDiv.textContent = title;

        const metaDiv = document.createElement("div");
        metaDiv.className = "video-meta";
        metaDiv.innerHTML = `
          <span class="meta-date">📅 ${formatDate(publishedAt)} (${timeSinceUpload(publishedAt)})</span>
          <span class="meta-views">👁️ ${formatNumber(views)}회</span>
          <span>👍 ${formatNumber(likes)}</span>
          <span>💬 ${formatNumber(comments)}</span>
          <span class="meta-subs">👥 ${formatNumber(subs)}명</span>
          <span class="meta-vph">⏱️ ${vph ? vph.toFixed(1) + " VPH" : "-"}</span>
        `;

        const linkDiv = document.createElement("div");
        linkDiv.className = "video-link";

        const openLink = document.createElement("a");
        openLink.className = "primary";
        openLink.href = "https://www.youtube.com/watch?v=" + encodeURIComponent(vid);
        openLink.target = "_blank";
        openLink.rel = "noopener noreferrer";
        openLink.textContent = "▶ YouTube에서 열기";
        linkDiv.appendChild(openLink);

        if (thumbUrl) {
          const thumbLink = document.createElement("a");
          thumbLink.href = thumbUrl;
          thumbLink.target = "_blank";
          thumbLink.rel = "noopener noreferrer";
          thumbLink.textContent = "⬇ 썸네일 다운로드";
          linkDiv.appendChild(thumbLink);
        }

        const analyzeBtn = document.createElement("button");
        analyzeBtn.type = "button";
        analyzeBtn.className = "btn-secondary small";
        analyzeBtn.textContent = "분석";
        analyzeBtn.addEventListener("click", () => {
          const analysis = generateLocalAnalysis(video);
          setAnalysisText(analysis);
          setStatus("선택한 영상의 메타데이터 기반 분석을 생성했습니다.", "info");
        });
        linkDiv.appendChild(analyzeBtn);

        bodyDiv.appendChild(titleDiv);
        bodyDiv.appendChild(metaDiv);
        bodyDiv.appendChild(linkDiv);

        card.appendChild(thumbDiv);
        card.appendChild(bodyDiv);

        fr.appendChild(card);
      });

      resultsListEl.innerHTML = "";
      resultsListEl.appendChild(fr);
    }

    // ===== 임시 분석 로직 (AI 연동 전 버전) =====
    function generateLocalAnalysis(video) {
      const snippet = video.snippet || {};
      const stats = video.statistics || {};
      const content = video.contentDetails || {};
      const title = snippet.title || "";
      const description = (snippet.description || "").slice(0, 500);
      const views = Number(stats.viewCount || 0);
      const subs = Number(video._subscriberCount || 0);
      const durationSec = isoDurationToSeconds(content.duration || "");
      const vph = calcVph(video);
      const publishedAt = snippet.publishedAt || "";

      return [
        `■ 영상 기본 정보`,
        `- 제목: ${title}`,
        `- 게시일: ${formatDate(publishedAt)} (${timeSinceUpload(publishedAt)})`,
        `- 길이: ${formatSecondsToHMS(durationSec)} (${(durationSec / 60).toFixed(1)}분)`,
        `- 조회수: ${formatNumber(views)}`,
        `- 채널 구독자: ${formatNumber(subs)}명`,
        `- VPH(시간당 조회수): ${vph ? vph.toFixed(1) : "-"} VPH`,
        ``,
        `■ 메타 기반 추정 분석`,
        `- 구조·서사: 제목과 설명을 기반으로, 한 편의 사연형 K-드라마/다큐 스타일 영상일 가능성이 높습니다.`,
        `- 감정 톤: 강한 갈등/반전, 가족·인간관계, 후회/통쾌한 복수 등 고연령층이 좋아하는 감정선일 수 있습니다.`,
        `- 시점 추정:`,
        `  · 제목·설명이 "나는", "내가", "우리" 위주면 1인칭 사연 중심일 가능성이 큽니다.`,
        `  · 제3의 인물을 설명하는 문장이 많으면 3인칭 해설형 내레이션 구조일 수 있습니다.`,
        `- 주제 범주 예시:`,
        `  · 가족·결혼·이혼·시댁·장례식·유산 분쟁·병원·응급실 등`,
        `  · 노년층의 경제·건강·관계, 과거의 잘못과 뒤늦은 사과/복수`,
        ``,
        `■ 메타 설명(요약용 텍스트)`,
        description
          ? `- 설명(앞부분 500자):\n${description}`
          : `- 설명 텍스트가 거의 없어, 실제 스크립트/자막 기반 추가 분석이 필요합니다.`,
        ``,
        `※ 현재 버전은 "제목 + 설명 + 메타데이터"만으로 대략적인 분석을 한 상태입니다.`,
        `  실제 스크립트/자막까지 불러와서 서사 구조, 감정 변화, 시점(1·3인칭)을 정밀 분석하려면`,
        `  백엔드에서 OpenAI API 등의 LLM과 연동해 추가 분석을 수행하는 구조로 확장하는 것이 좋습니다.`
      ].join("\n");
    }

    // ===== 통계 =====
    function resetStats() {
      statTotalViewsEl.textContent = "-";
      statAvgViewsEl.textContent = "-";
      statAvgVphEl.textContent = "-";
      statAvgDurationEl.textContent = "-";
      statAvgTitleLenEl.textContent = "-";
      statLatestEl.textContent = "-";
      keywordListEl.innerHTML =
        '<span class="empty-state">제목 데이터를 불러오면 여기에서 많이 쓰인 단어들을 보여줍니다.</span>';
    }

    function computeStats() {
      if (!currentVideos.length) {
        resetStats();
        return;
      }

      let totalViews = 0;
      let totalDurationSec = 0;
      let totalTitleLen = 0;
      let totalVph = 0;
      let vphCount = 0;
      let latestDate = null;
      const keywordFreq = new Map();

      currentVideos.forEach((v) => {
        const snippet = v.snippet || {};
        const stats = v.statistics || {};
        const content = v.contentDetails || {};

        const views = Number(stats.viewCount || 0);
        const publishedAt = snippet.publishedAt || "";
        const durationSeconds = isoDurationToSeconds(content.duration || "");
        const title = snippet.title || "";

        totalViews += views;
        totalDurationSec += durationSeconds;
        totalTitleLen += title.length;

        const t = new Date(publishedAt).getTime();
        if (!isNaN(t)) {
          if (!latestDate || t > latestDate.getTime()) latestDate = new Date(t);
          const diffHours = (Date.now() - t) / (1000 * 60 * 60);
          if (diffHours > 0) {
            totalVph += views / diffHours;
            vphCount++;
          }
        }

        tokenizeTitle(title).forEach((token) => {
          keywordFreq.set(token, (keywordFreq.get(token) || 0) + 1);
        });
      });

      const count = currentVideos.length;
      const avgViews = totalViews / count;
      const avgDurationSec = totalDurationSec / count;
      const avgTitleLen = totalTitleLen / count;
      const avgVph = vphCount > 0 ? totalVph / vphCount : null;

      statTotalViewsEl.textContent = formatNumber(totalViews);
      statAvgViewsEl.textContent = isFinite(avgViews)
        ? formatNumber(Math.round(avgViews))
        : "-";
      statAvgDurationEl.textContent = isFinite(avgDurationSec)
        ? (avgDurationSec / 60).toFixed(1) + "분"
        : "-";
      statAvgTitleLenEl.textContent = isFinite(avgTitleLen)
        ? avgTitleLen.toFixed(1) + "자"
        : "-";
      statAvgVphEl.textContent =
        avgVph !== null && isFinite(avgVph)
          ? avgVph.toFixed(1) + " VPH"
          : "-";
      statLatestEl.textContent = latestDate
        ? formatDate(latestDate.toISOString())
        : "-";

      renderKeywordTop(keywordFreq);
    }

    function renderKeywordTop(freqMap) {
      keywordListEl.innerHTML = "";
      if (!freqMap || !freqMap.size) {
        keywordListEl.innerHTML =
          '<span class="empty-state">제목 데이터를 불러오면 여기에서 많이 쓰인 단어들을 보여줍니다.</span>';
        return;
      }

      const arr = Array.from(freqMap.entries());
      const stopwords = new Set([
        "영상", "정말", "오늘", "이혼", "전처", "이야기", "사연", "사람", "우리",
        "그녀", "그는", "당한", "후", "까지", "그리고"
      ]);

      const filtered = arr
        .filter(([token, count]) => {
          if (count < 2) return false;
          if (stopwords.has(token)) return false;
          return true;
        })
        .sort((a, b) => b[1] - a[1])
        .slice(0, 15);

      if (!filtered.length) {
        keywordListEl.innerHTML =
          '<span class="empty-state">자주 반복되는 키워드가 거의 없습니다.</span>';
        return;
      }

      filtered.forEach(([token, count]) => {
        const chip = document.createElement("span");
        chip.className = "keyword-chip";
        chip.innerHTML = token + '<span class="count">×' + count + "</span>";
        keywordListEl.appendChild(chip);
      });
    }

    // ===== CSV 내보내기 =====
    function exportCsv() {
      if (!currentVideos.length) return;
      const rows = [];
      rows.push([
        "videoId",
        "title",
        "publishedAt",
        "durationSeconds",
        "views",
        "likes",
        "comments",
        "subscriberCount",
        "VPH",
        "url"
      ]);

      currentVideos.forEach((video) => {
        const snippet = video.snippet || {};
        const stats = video.statistics || {};
        const content = video.contentDetails || {};
        const vid = video.id;
        const title = (snippet.title || "").replace(/"/g, '""');
        const publishedAt = snippet.publishedAt || "";
        const durationSeconds = isoDurationToSeconds(content.duration || "");
        const views = Number(stats.viewCount || 0);
        const likes = Number(stats.likeCount || 0);
        const comments = Number(stats.commentCount || 0);
        const subs = Number(video._subscriberCount || 0);
        const vph = calcVph(video);

        rows.push([
          vid,
          '"' + title + '"',
          publishedAt,
          durationSeconds,
          views,
          likes,
          comments,
          subs,
          vph.toFixed ? vph.toFixed(2) : vph,
          "https://www.youtube.com/watch?v=" + vid
        ]);
      });

      const csv = rows.map((row) => row.join(",")).join("\r\n");
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      const now = new Date();
      const ts =
        now.getFullYear().toString() +
        String(now.getMonth() + 1).padStart(2, "0") +
        String(now.getDate()).padStart(2, "0") +
        "_" +
        String(now.getHours()).padStart(2, "0") +
        String(now.getMinutes()).padStart(2, "0");
      a.download = "youtube_analysis_" + ts + ".csv";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ===== 이벤트 바인딩 =====
    // 모드 토글
    modeButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const mode = btn.dataset.mode;
        currentMode = mode;
        modeButtons.forEach((b) => b.classList.toggle("active", b === btn));
        if (mode === "channel") {
          channelField.style.display = "";
          keywordField.style.display = "none";
        } else {
          channelField.style.display = "none";
          keywordField.style.display = "";
        }
      });
    });

    // 정렬 방향 버튼
    sortDirButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        sortDirection = btn.dataset.dir;
        sortDirButtons.forEach((b) => b.classList.toggle("active", b === btn));
        applyFiltersAndSort();
      });
    });

    // 정렬 기준 변경
    sortFieldSelect.addEventListener("change", applyFiltersAndSort);

    // 필터 변경
    [minViewsInput, maxViewsInput, minSubsInput, maxSubsInput].forEach((el) => {
      el.addEventListener("change", applyFiltersAndSort);
    });
    excludeLiveInput.addEventListener("change", applyFiltersAndSort);
    excludeShortsInput.addEventListener("change", applyFiltersAndSort);

    // 조회 버튼 / CSV
    fetchBtn.addEventListener("click", fetchVideos);
    exportCsvBtn.addEventListener("click", exportCsv);

    // 엔터 키로 검색 실행
    [channelIdInput, keywordInput, maxResultsInput, daysRangeInput].forEach((el) => {
      el.addEventListener("keydown", (e) => {
        if (e.key === "Enter") fetchVideos();
      });
    });

    // 분석 내용 복사
    copyAnalysisBtn.addEventListener("click", async () => {
      if (!lastAnalysisText) return;
      try {
        await navigator.clipboard.writeText(lastAnalysisText);
        setStatus("분석 내용을 클립보드에 복사했습니다.", "info");
      } catch {
        setStatus("복사에 실패했습니다. 브라우저 권한을 확인해주세요.", "error");
      }
    });

    // 초기 상태
    resetStats();
    setAnalysisText("");
  </script>
</body>
</html>
