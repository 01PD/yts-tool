<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>YouTube 채널 분석 툴 v1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b1120;
      --bg-alt: #020617;
      --card: #020617;
      --accent: #38bdf8;
      --accent-soft: rgba(56,189,248,0.15);
      --border: #1f2937;
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --danger: #f97373;
      --radius-lg: 18px;
      --shadow-soft: 0 18px 40px rgba(0,0,0,0.45);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1e293b 0, #020617 45%, #000 100%);
      color: var(--text);
      overflow-x: hidden;
    }

    .app {
      max-width: 1400px;
      margin: 0 auto;
      padding: 16px 16px 32px;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      gap: 10px;
      margin-bottom: 10px;
    }

    header h1 {
      font-size: 1.4rem;
      margin: 0;
      font-weight: 700;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    header h1 span.badge {
      font-size: 0.7rem;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      color: var(--text-soft);
    }

    header p {
      margin: 0;
      font-size: 0.82rem;
      color: var(--text-soft);
    }

    /* ===== 3단 레이아웃: 좌 1/6, 중간 4/6, 우 1/6 ===== */
    .main-layout {
      display: grid;
      grid-template-columns: minmax(180px, 1fr) minmax(0, 4fr) minmax(220px, 1fr);
      gap: 12px;
      min-height: calc(100vh - 80px);
    }

    .panel {
      display: flex;
      flex-direction: column;
    }

    .panel-inner {
      background: radial-gradient(circle at top left, #020617 0, #020617 20%, #020617 55%, #000 100%);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(148,163,184,0.15);
      box-shadow: var(--shadow-soft);
      padding: 12px 12px 14px;
      display: flex;
      flex-direction: column;
      height: 100%;
      min-height: 260px;
    }

    .panel-title-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 8px;
    }

    .panel-title-row h2 {
      margin: 0;
      font-size: 0.95rem;
    }

    .panel-title-row span {
      font-size: 0.76rem;
      color: var(--text-soft);
    }

    @media (max-width: 1000px) {
      .main-layout {
        grid-template-columns: 1fr;
      }
      .panel-inner {
        min-height: auto;
      }
    }

    /* ===== 폼 / 컨트롤 ===== */
    .controls-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      align-items: flex-start;
      margin-bottom: 6px;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.78rem;
    }

    .field label {
      color: var(--text-soft);
    }

    .input, select {
      padding: 7px 9px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.8);
      color: var(--text);
      font-size: 0.86rem;
      outline: none;
    }

    .input:focus, select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.3);
    }

    .input::placeholder {
      color: #6b7280;
    }

    .help-text {
      font-size: 0.72rem;
      color: var(--text-soft);
    }

    .mode-toggle {
      display: flex;
      gap: 6px;
      font-size: 0.72rem;
    }

    .mode-button {
      flex: 1;
      padding: 5px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.7);
      color: var(--text-soft);
      cursor: pointer;
    }

    .mode-button.active {
      border-color: var(--accent);
      background: var(--accent-soft);
      color: var(--accent);
    }

    .btn-primary {
      padding: 8px 12px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 0.86rem;
      font-weight: 600;
      background: linear-gradient(135deg, #38bdf8, #22c55e);
      color: #0b1120;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      white-space: nowrap;
    }

    .btn-secondary {
      padding: 6px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      cursor: pointer;
      font-size: 0.78rem;
      background: rgba(15,23,42,0.7);
      color: var(--text-soft);
      white-space: nowrap;
    }

    .btn-secondary.small {
      padding: 3px 8px;
      font-size: 0.75rem;
    }

    .btn-primary:disabled,
    .btn-secondary:disabled {
      opacity: 0.4;
      cursor: default;
    }

    .controls-actions {
      display: flex;
      gap: 6px;
      justify-content: flex-end;
      align-items: center;
      margin-top: 4px;
      flex-wrap: wrap;
    }

    .status-bar {
      margin-top: 6px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.76rem;
      color: var(--text-soft);
    }

    .status-message {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .status-message.danger {
      color: var(--danger);
    }

    .status-message.loading-dot::after {
      content: " •";
      animation: dots 1s infinite steps(3, end);
    }

    @keyframes dots {
      0%, 20% { content: " •"; }
      40% { content: " ••"; }
      60%, 100% { content: " •••"; }
    }

    .pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.35);
      font-size: 0.74rem;
      color: var(--text-soft);
      align-self: flex-end;
    }

    .pill strong {
      color: var(--accent);
      font-weight: 600;
    }

    .range-row {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .range-row input {
      flex: 1;
    }

    .range-row span {
      font-size: 0.75rem;
      color: var(--text-soft);
    }

    .checkbox-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.76rem;
    }

    .checkbox-row label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }

    .checkbox-row input {
      accent-color: var(--accent);
    }

    /* ===== 결과 리스트 (가운데 4/6 영역) ===== */
    .results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    .results-header h2 {
      margin: 0;
      font-size: 0.95rem;
    }

    .results-toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.78rem;
      flex-wrap: wrap;
    }

    .results-toolbar label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .results-toolbar select {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
      color: var(--text-soft);
      font-size: 0.78rem;
    }

    .sort-dir-btn {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
      color: var(--text-soft);
      font-size: 0.76rem;
      cursor: pointer;
    }

    .sort-dir-btn.active {
      border-color: var(--accent);
      background: var(--accent-soft);
      color: var(--accent);
    }

    .results-toolbar span#resultsInfo {
      color: var(--text-soft);
    }

    .results-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding-right: 2px;
      flex: 1;
      max-height: calc(100vh - 170px);
      overflow-y: auto;
      overflow-x: hidden;
    }

    .video-card {
      display: grid;
      grid-template-columns: 260px minmax(0, 1fr);
      gap: 12px;
      background: rgba(15,23,42,0.9);
      border-radius: 14px;
      border: 1px solid rgba(55,65,81,0.7);
      overflow: hidden;
      min-height: 150px;
    }

    @media (max-width: 900px) {
      .video-card {
        grid-template-columns: 1fr;
      }
    }

    .video-thumb {
      position: relative;
      overflow: hidden;
      aspect-ratio: 16 / 9;
    }

    .video-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .video-duration {
      position: absolute;
      right: 6px;
      bottom: 6px;
      font-size: 0.72rem;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(0,0,0,0.75);
      color: #f9fafb;
    }

    .video-body {
      padding: 8px 10px 9px 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .video-title {
      font-size: 0.9rem;
      font-weight: 600;
      line-height: 1.3;
    }

    .video-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 0.75rem;
      color: var(--text-soft);
    }

    .video-meta span {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    /* 색상 지정 */
    .meta-date {
      color: #fb923c;  /* 주황 */
    }
    .meta-views {
      color: #facc15;  /* 노랑 */
    }
    .meta-subs {
      color: #38bdf8;  /* 하늘색 */
    }
    .meta-vph {
      color: #22c55e;  /* 초록색 */
    }

    .video-link {
      margin-top: 4px;
      font-size: 0.76rem;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .video-link a {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.95);
      color: var(--accent);
      text-decoration: none;
    }

    .video-link a.primary {
      background: var(--accent-soft);
    }

    .video-link a:hover {
      text-decoration: underline;
    }

    /* ===== 채널 후보 카드 ===== */
    .channel-card {
      display: grid;
      grid-template-columns: 80px minmax(0, 1fr);
      gap: 12px;
      background: rgba(15,23,42,0.9);
      border-radius: 14px;
      border: 1px solid rgba(55,65,81,0.7);
      padding: 8px;
      cursor: pointer;
    }

    .channel-card:hover {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.3);
    }

    .channel-thumb {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .channel-thumb img {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      object-fit: cover;
    }

    .channel-body .channel-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .channel-body .channel-id {
      font-size: 0.76rem;
      color: var(--text-soft);
    }

    .channel-body .channel-hint {
      font-size: 0.74rem;
      color: var(--accent);
      margin-top: 4px;
    }

    /* ===== 좌측 요약 분석 (1/6) ===== */
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
      font-size: 0.8rem;
      margin-bottom: 6px;
    }

    .stat-item {
      padding: 6px 7px;
      border-radius: 10px;
      background: rgba(15,23,42,0.95);
      border: 1px solid rgba(31,41,55,0.9);
    }

    .stat-label {
      font-size: 0.72rem;
      color: var(--text-soft);
      margin-bottom: 1px;
    }

    .stat-value {
      font-size: 0.88rem;
      font-weight: 600;
    }

    .analysis-block {
      margin-top: 6px;
    }

    .analysis-block h3 {
      margin: 0 0 4px;
      font-size: 0.86rem;
    }

    .keyword-list {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      font-size: 0.76rem;
      max-height: 90px;
      overflow: auto;
    }

    .keyword-chip {
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(15,23,42,0.95);
      border: 1px solid rgba(55,65,81,0.8);
    }

    .keyword-chip span.count {
      color: var(--accent);
      margin-left: 4px;
    }

    .analysis-header {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      margin-bottom: 4px;
      gap: 6px;
    }

    .analysis-content {
      max-height: 180px;
      overflow-y: auto;
      font-size: 0.78rem;
      background: rgba(15,23,42,0.95);
      border-radius: 10px;
      border: 1px solid rgba(31,41,55,0.9);
      padding: 6px 8px;
      white-space: pre-wrap;
      line-height: 1.4;
    }

    .copy-btn {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.6);
      background: rgba(15,23,42,0.9);
      color: var(--text-soft);
      font-size: 0.76rem;
      cursor: pointer;
    }

    .copy-btn:disabled {
      opacity: 0.4;
      cursor: default;
    }

    .empty-state {
      font-size: 0.78rem;
      color: var(--text-soft);
      padding: 8px 0;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>
        YouTube 채널 분석 툴
        <span class="badge">v1 · HTML Only</span>
      </h1>
      <p>채널·영상 메타데이터를 브라우저에서 바로 분석합니다.</p>
    </header>

    <!-- ===== 3단 메인 레이아웃 ===== -->
    <section class="main-layout">
      <!-- 좌측 1/6 : 요약 분석 -->
      <aside class="panel">
        <div class="panel-inner">
          <div class="panel-title-row">
            <h2>요약 분석</h2>
            <span>기본 통계 & 제목 키워드</span>
          </div>

          <div id="statsContainer" class="stats-grid">
            <div class="stat-item">
              <div class="stat-label">총 조회수 합계</div>
              <div class="stat-value" id="statTotalViews">-</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">영상 1개당 평균 조회수</div>
              <div class="stat-value" id="statAvgViews">-</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">평균 VPH (조회수/업로드 후 시간)</div>
              <div class="stat-value" id="statAvgVph">-</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">평균 길이 (분)</div>
              <div class="stat-value" id="statAvgDuration">-</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">평균 제목 글자 수</div>
              <div class="stat-value" id="statAvgTitleLen">-</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">가장 최근 업로드</div>
              <div class="stat-value" id="statLatest">-</div>
            </div>
          </div>

          <div class="analysis-block">
            <h3>제목 키워드 TOP 15</h3>
            <div id="keywordList" class="keyword-list">
              <span class="empty-state">
                제목 데이터를 불러오면 여기에서 많이 쓰인 단어들을 보여줍니다.
              </span>
            </div>
          </div>

          <div class="analysis-block">
            <h3>분석 결과</h3>
            <div class="analysis-header">
              <button type="button" id="copyAnalysisBtn" class="copy-btn" disabled>
                분석 내용 복사
              </button>
            </div>
            <div id="analysisContent" class="analysis-content">
              <div class="help-text">
                아직 분석된 영상이 없습니다. 가운데 목록의 영상 카드에서
                <strong>「분석」 버튼</strong>을 누르면 여기 결과가 표시됩니다.
              </div>
            </div>
          </div>
        </div>
      </aside>

      <!-- 가운데 4/6 : 결과 리스트 -->
      <main class="panel">
        <div class="panel-inner">
          <div class="results-header">
            <h2>영상 / 채널 목록</h2>
            <div class="results-toolbar">
              <label for="resultSortField">
                <span>정렬 기준</span>
                <select id="resultSortField">
                  <option value="views">조회수</option>
                  <option value="date">게시일</option>
                  <option value="subs">구독자</option>
                  <option value="vph">VPH</option>
                </select>
              </label>
              <button type="button" class="sort-dir-btn active" data-dir="desc">높은 순</button>
              <button type="button" class="sort-dir-btn" data-dir="asc">낮은 순</button>
              <span id="resultsInfo">아직 불러온 데이터가 없습니다.</span>
            </div>
          </div>
          <div id="resultsList" class="results-list">
            <div class="empty-state">
              이 영역에 분석 대상 영상 카드 또는 채널 후보 카드가 표시됩니다.
            </div>
          </div>
        </div>
      </main>

      <!-- 우측 1/6 : 검색/필터 영역 -->
      <aside class="panel">
        <div class="panel-inner">
          <div class="panel-title-row">
            <h2>검색 & 필터</h2>
            <span style="font-size:0.74rem;">우측 패널에서 조건 설정</span>
          </div>

          <div class="controls-grid">
            <div class="field">
              <label for="apiKey">YouTube API 키 <span style="color:#f97373">*</span></label>
              <input
                id="apiKey"
                class="input"
                type="password"
                placeholder="브라우저 키를 여기 입력 (코드에 직접 넣지 마세요)"
              />
              <div class="help-text">
                Google Cloud에서 얻은 <strong>API 키</strong>를 입력하세요.
                키는 코드에 적지 말고, 항상 이 입력창에 붙여넣는 방식으로 사용하세요.
              </div>
            </div>

            <div class="field">
              <label>검색 모드</label>
              <div class="mode-toggle">
                <button type="button" class="mode-button active" data-mode="channel">
                  채널 기준
                </button>
                <button type="button" class="mode-button" data-mode="keyword">
                  키워드 / 링크
                </button>
              </div>
              <div class="help-text">
                채널(링크/ID/이름) 기준 분석 또는 키워드/영상링크 기준 분석 중 선택.
              </div>
            </div>

            <div class="field" id="channelField">
              <label for="channelId">채널 입력</label>
              <input
                id="channelId"
                class="input"
                type="text"
                placeholder="채널 URL, ID(UC...), @핸들, 또는 채널 이름(예: 사연그네)"
              />
              <div class="help-text">
                예시: <br />
                · <code>https://www.youtube.com/@sayongeune</code><br />
                · <code>https://www.youtube.com/channel/UCxxxx</code><br />
                · <code>@sayongeune</code> 또는 <code>UCxxxx...</code><br />
                · <code>사연그네</code> (채널 이름으로 검색)
              </div>
            </div>

            <div class="field" id="keywordField" style="display:none;">
              <label for="keyword">키워드 / 영상 URL</label>
              <input
                id="keyword"
                class="input"
                type="text"
                placeholder="키워드 또는 영상 링크 (예: https://youtu.be/...)"
              />
              <div class="help-text">
                · 키워드: <code>이혼 후 10년, 장례식 복수...</code><br />
                · 또는 <strong>영상 URL</strong>을 넣으면 그 영상만 단독 분석합니다.
              </div>
            </div>

            <div class="field">
              <label for="order">API 정렬 기준</label>
              <select id="order">
                <option value="date">최신순</option>
                <option value="viewCount">조회수 순</option>
                <option value="relevance">관련도 순 (키워드 사용 시)</option>
              </select>
              <div class="help-text">YouTube Data API 정렬 기준 (기본 순서)입니다.</div>
            </div>

            <div class="field">
              <label for="maxResults">최대 영상 개수 (1~150)</label>
              <input
                id="maxResults"
                class="input"
                type="number"
                min="1"
                max="150"
                value="50"
              />
              <div class="help-text">페이지네이션을 돌리며 최대 이 숫자까지 가져옵니다.</div>
            </div>

            <div class="field">
              <label for="daysRange">최근 N일 이내 업로드만</label>
              <input
                id="daysRange"
                class="input"
                type="number"
                min="0"
                value="0"
              />
              <div class="help-text">0이면 기간 제한 없음, 30이면 최근 한 달 영상만 분석.</div>
            </div>

            <div class="field">
              <label>조회수 범위</label>
              <div class="range-row">
                <input id="minViews" class="input" type="number" min="0" value="10000" />
                <span>~</span>
                <input id="maxViews" class="input" type="number" min="0" placeholder="무제한" />
              </div>
              <div class="help-text">
                예: 최소 10000, 최대 비워두면 조회수 상한 제한 없음.
              </div>
            </div>

            <div class="field">
              <label>구독자 수 범위 (채널)</label>
              <div class="range-row">
                <input id="minSubs" class="input" type="number" min="0" value="0" />
                <span>~</span>
                <input id="maxSubs" class="input" type="number" min="0" value="10000" />
              </div>
              <div class="help-text">
                채널 구독자 수 기준 필터. 최대를 비우면 상한 제한 없음.
              </div>
            </div>

            <div class="field">
              <label>타입 필터</label>
              <div class="checkbox-row">
                <label>
                  <input type="checkbox" id="excludeLive" />
                  <span>라이브 제외</span>
                </label>
                <label>
                  <input type="checkbox" id="excludeShorts" />
                  <span>숏폼 제외 (&lt; 60초)</span>
                </label>
              </div>
              <div class="help-text">
                체크하면 해당 유형의 영상은 결과에서 제외됩니다.
              </div>
            </div>
          </div>

          <div class="controls-actions">
            <button type="button" class="btn-secondary" id="exportCsvBtn" disabled>
              CSV 다운로드
            </button>
            <button type="button" class="btn-primary" id="fetchBtn">
              불러오기 & 분석
            </button>
          </div>

          <div class="status-bar">
            <div class="status-message" id="statusMessage">
              준비 완료. API 키와 조건을 입력하고 실행하세요.
            </div>
            <div class="pill" id="statusSummary">
              <span>분석된 영상: <strong>0</strong>개</span>
            </div>
          </div>
        </div>
      </aside>
    </section>
  </div>

  <script>
    // ------ 간단한 상태 ------
    let currentMode = "channel"; // "channel" | "keyword"
    let allVideos = [];          // 필터/정렬 전 전체 영상
    let currentVideos = [];      // 필터/정렬 후 화면에 보여줄 영상들
    let sortDirection = "desc";  // "desc" | "asc"
    let lastAnalysisText = "";

    const modeButtons = document.querySelectorAll(".mode-button");
    const channelField = document.getElementById("channelField");
    const keywordField = document.getElementById("keywordField");

    const apiKeyInput = document.getElementById("apiKey");
    const channelIdInput = document.getElementById("channelId");
    const keywordInput = document.getElementById("keyword");
    const orderSelect = document.getElementById("order");
    const maxResultsInput = document.getElementById("maxResults");
    const daysRangeInput = document.getElementById("daysRange");

    const minViewsInput = document.getElementById("minViews");
    const maxViewsInput = document.getElementById("maxViews");
    const minSubsInput = document.getElementById("minSubs");
    const maxSubsInput = document.getElementById("maxSubs");
    const excludeLiveInput = document.getElementById("excludeLive");
    const excludeShortsInput = document.getElementById("excludeShorts");

    const sortFieldSelect = document.getElementById("resultSortField");
    const sortDirButtons = document.querySelectorAll(".sort-dir-btn");

    const fetchBtn = document.getElementById("fetchBtn");
    const exportCsvBtn = document.getElementById("exportCsvBtn");

    const statusMessageEl = document.getElementById("statusMessage");
    const statusSummaryEl = document.getElementById("statusSummary");
    const resultsInfoEl = document.getElementById("resultsInfo");
    const resultsListEl = document.getElementById("resultsList");

    const statTotalViewsEl = document.getElementById("statTotalViews");
    const statAvgViewsEl = document.getElementById("statAvgViews");
    const statAvgVphEl = document.getElementById("statAvgVph");
    const statAvgDurationEl = document.getElementById("statAvgDuration");
    const statAvgTitleLenEl = document.getElementById("statAvgTitleLen");
    const statLatestEl = document.getElementById("statLatest");
    const keywordListEl = document.getElementById("keywordList");

    const analysisContentEl = document.getElementById("analysisContent");
    const copyAnalysisBtn = document.getElementById("copyAnalysisBtn");

    // ------ 모드 토글 ------
    modeButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const mode = btn.dataset.mode;
        currentMode = mode;
        modeButtons.forEach((b) => b.classList.toggle("active", b === btn));
        if (mode === "channel") {
          channelField.style.display = "";
          keywordField.style.display = "none";
        } else {
          channelField.style.display = "none";
          keywordField.style.display = "";
        }
      });
    });

    // ------ 정렬 방향 버튼 ------
    sortDirButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        sortDirection = btn.dataset.dir;
        sortDirButtons.forEach((b) => b.classList.toggle("active", b === btn));
        applyFiltersAndSort();
      });
    });

    // ------ 유틸리티 함수들 ------
    function setStatus(message, type = "info", loading = false) {
      statusMessageEl.textContent = message;
      statusMessageEl.classList.toggle("danger", type === "error");
      statusMessageEl.classList.toggle("loading-dot", loading);
    }

    function updateSummaryCount(count) {
      statusSummaryEl.innerHTML = '분석된 영상: <strong>' + count + "</strong>개";
    }

    function formatNumber(num) {
      if (num === null || num === undefined || isNaN(num)) return "-";
      return Number(num).toLocaleString("ko-KR");
    }

    function formatDate(dateStr) {
      const d = new Date(dateStr);
      if (isNaN(d.getTime())) return "-";
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return y + "." + m + "." + day;
    }

    function timeSinceUpload(dateStr) {
      const now = Date.now();
      const t = new Date(dateStr).getTime();
      if (isNaN(t)) return "-";
      const diffMs = now - t;
      const diffDays = diffMs / (1000 * 60 * 60 * 24);
      if (diffDays < 1) {
        const hours = diffMs / (1000 * 60 * 60);
        return hours.toFixed(1) + "시간 전";
      }
      if (diffDays < 30) {
        return Math.floor(diffDays) + "일 전";
      }
      const months = diffDays / 30;
      if (months < 12) {
        return Math.floor(months) + "개월 전";
      }
      const years = diffDays / 365;
      return Math.floor(years) + "년 전";
    }

    function isoDurationToSeconds(iso) {
      if (!iso || typeof iso !== "string") return 0;
      const match = iso.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
      if (!match) return 0;
      const hours = parseInt(match[1] || "0", 10);
      const minutes = parseInt(match[2] || "0", 10);
      const seconds = parseInt(match[3] || "0", 10);
      return hours * 3600 + minutes * 60 + seconds;
    }

    function formatSecondsToHMS(totalSeconds) {
      if (!totalSeconds || isNaN(totalSeconds)) return "00:00";
      const h = Math.floor(totalSeconds / 3600);
      const m = Math.floor((totalSeconds % 3600) / 60);
      const s = totalSeconds % 60;
      if (h > 0) {
        return [h, m.toString().padStart(2, "0"), s.toString().padStart(2, "0")].join(":");
      }
      return [m, s.toString().padStart(2, "0")].map((v) => v.toString().padStart(2, "0")).join(":");
    }

    function tokenizeTitle(title) {
      if (!title) return [];
      const cleaned = title
        .replace(/[^\p{L}\p{N}\s]/gu, " ")
        .replace(/\s+/g, " ")
        .trim();
      if (!cleaned) return [];
      const tokens = cleaned.split(" ");
      return tokens.filter((t) => t.length > 1);
    }

    function extractVideoIdFromInput(raw) {
      const input = raw.trim();
      if (!input) return null;
      if (/^[0-9A-Za-z_-]{11}$/.test(input)) return input;
      if (!input.startsWith("http")) return null;
      try {
        const u = new URL(input);
        const host = u.hostname.replace(/^www\./, "");
        const pathParts = u.pathname.split("/").filter(Boolean);

        const vParam = u.searchParams.get("v");
        if (vParam && /^[0-9A-Za-z_-]{11}$/.test(vParam)) return vParam;

        if (host === "youtu.be" && pathParts[0] && /^[0-9A-Za-z_-]{11}$/.test(pathParts[0])) {
          return pathParts[0];
        }

        const idx = pathParts.findIndex((p) => p === "shorts" || p === "embed");
        if (idx >= 0 && pathParts[idx + 1] && /^[0-9A-Za-z_-]{11}$/.test(pathParts[idx + 1])) {
          return pathParts[idx + 1];
        }
      } catch (e) {
        return null;
      }
      return null;
    }

    // 채널 입력 처리: URL / ID / @ / 이름 → 채널 ID 또는 후보 리스트
    async function resolveChannelFromInput(apiKey, rawInput) {
      const input = rawInput.trim();
      if (!input) {
        throw new Error("채널 입력이 비어 있습니다.");
      }

      if (/^UC[0-9A-Za-z_-]{20,}$/.test(input)) {
        return { type: "id", id: input };
      }

      let handle = null;
      let channelId = null;
      let nameQuery = null;

      if (input.startsWith("http")) {
        try {
          const u = new URL(input);
          const host = u.hostname.replace(/^www\./, "");
          const parts = u.pathname.split("/").filter(Boolean);

          if (host === "youtube.com" || host === "m.youtube.com") {
            if (parts[0] === "channel" && parts[1]) {
              channelId = parts[1];
            } else if (parts[0] && parts[0].startsWith("@")) {
              handle = "@" + parts[0].replace(/^@/, "");
            } else if ((parts[0] === "c" || parts[0] === "user") && parts[1]) {
              nameQuery = decodeURIComponent(parts[1]);
            }
          }
        } catch (e) {
          // ignore
        }
      }

      if (!handle && input.startsWith("@")) {
        handle = input;
      }

      if (channelId) {
        return { type: "id", id: channelId };
      }

      if (handle) {
        const handleClean = handle.replace(/^@/, "");
        const params = new URLSearchParams({
          key: apiKey,
          part: "snippet",
          forHandle: handleClean,
        });
        const url = "https://www.googleapis.com/youtube/v3/channels?" + params.toString();
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error("채널 핸들 조회 실패 (HTTP " + res.status + ")");
        }
        const data = await res.json();
        if (data.items && data.items.length > 0) {
          return { type: "id", id: data.items[0].id };
        }
        throw new Error("해당 핸들의 채널을 찾을 수 없습니다.");
      }

      // 채널 이름 검색
      nameQuery = nameQuery || input;
      const searchParams = new URLSearchParams({
        key: apiKey,
        part: "snippet",
        q: nameQuery,
        type: "channel",
        maxResults: "25",
      });
      const url = "https://www.googleapis.com/youtube/v3/search?" + searchParams.toString();
      const res = await fetch(url);
      if (!res.ok) {
        const errData = await res.json().catch(() => ({}));
        const msg =
          errData.error && errData.error.message
            ? errData.error.message
            : "채널 이름 검색 실패 (HTTP " + res.status + ")";
        throw new Error(msg);
      }
      const data = await res.json();
      let items = data.items || [];
      if (!items.length) {
        throw new Error("해당 이름의 채널을 찾을 수 없습니다.");
      }

      const trimmed = nameQuery.trim();
      const exactMatches = items.filter(
        (it) =>
          it.snippet &&
          it.snippet.title &&
          it.snippet.title.trim() === trimmed
      );

      const toChannelObj = (it) => {
        const sn = it.snippet || {};
        const thumbs = sn.thumbnails || {};
        const thumbObj = thumbs.medium || thumbs.default || null;
        return {
          id: it.id.channelId,
          title: sn.title || "",
          description: sn.description || "",
          thumbnail: thumbObj,
        };
      };

      if (exactMatches.length === 1) {
        return { type: "id", id: exactMatches[0].id.channelId };
      }

      if (exactMatches.length > 1) {
        return {
          type: "multi",
          channels: exactMatches.map(toChannelObj),
        };
      }

      const channels = items.map(toChannelObj);
      if (channels.length === 1) {
        return { type: "id", id: channels[0].id };
      }
      return { type: "multi", channels };
    }

    // 채널 구독자 수 붙이기
    async function attachChannelSubs(apiKey, videos) {
      const channelIds = Array.from(
        new Set(
          videos
            .map((v) => (v.snippet && v.snippet.channelId) || null)
            .filter(Boolean)
        )
      );
      if (!channelIds.length) return;
      const subsMap = {};

      for (let i = 0; i < channelIds.length; i += 50) {
        const batch = channelIds.slice(i, i + 50);
        const params = new URLSearchParams({
          key: apiKey,
          part: "statistics",
          id: batch.join(","),
        });
        const url = "https://www.googleapis.com/youtube/v3/channels?" + params.toString();
        const res = await fetch(url);
        if (!res.ok) {
          console.warn("channels.list 실패", res.status);
          return;
        }
        const data = await res.json();
        (data.items || []).forEach((ch) => {
          const stats = ch.statistics || {};
          const subs = Number(stats.subscriberCount || 0);
          subsMap[ch.id] = subs;
        });
      }

      videos.forEach((v) => {
        const cid = v.snippet && v.snippet.channelId;
        v._subscriberCount = subsMap[cid] != null ? subsMap[cid] : 0;
      });
    }

    function calcVph(video) {
      const stats = video.statistics || {};
      const snippet = video.snippet || {};
      const views = Number(stats.viewCount || 0);
      const publishedAt = snippet.publishedAt || "";
      const t = new Date(publishedAt).getTime();
      if (isNaN(t)) return 0;
      const diffHours = (Date.now() - t) / (1000 * 60 * 60);
      if (diffHours <= 0) return 0;
      return views / diffHours;
    }

    // 분석 결과 설정
    function setAnalysisText(text) {
      lastAnalysisText = text || "";
      if (!text) {
        analysisContentEl.innerHTML =
          '<div class="help-text">분석된 내용이 없습니다. 가운데 카드의 「분석」 버튼을 눌러주세요.</div>';
        copyAnalysisBtn.disabled = true;
      } else {
        analysisContentEl.textContent = text;
        copyAnalysisBtn.disabled = false;
      }
    }

    // ------ 필터 & 정렬 적용 ------
    function applyFiltersAndSort() {
      if (!allVideos.length) {
        currentVideos = [];
        renderVideos();
        computeStats();
        resultsInfoEl.textContent = "0개의 영상";
        updateSummaryCount(0);
        exportCsvBtn.disabled = true;
        return;
      }

      let minViews = parseInt(minViewsInput.value || "0", 10);
      if (isNaN(minViews) || minViews < 0) minViews = 0;

      let maxViews = parseInt(maxViewsInput.value || "", 10);
      if (isNaN(maxViews) || maxViews <= 0) maxViews = Infinity;

      let minSubs = parseInt(minSubsInput.value || "0", 10);
      if (isNaN(minSubs) || minSubs < 0) minSubs = 0;

      let maxSubs = parseInt(maxSubsInput.value || "", 10);
      if (isNaN(maxSubs) || maxSubs <= 0) maxSubs = Infinity;

      const excludeLive = !!excludeLiveInput.checked;
      const excludeShorts = !!excludeShortsInput.checked;

      let filtered = allVideos.filter((video) => {
        const snippet = video.snippet || {};
        const stats = video.statistics || {};
        const content = video.contentDetails || {};
        const views = Number(stats.viewCount || 0);
        const subs = Number(video._subscriberCount || 0);
        const durationSeconds = isoDurationToSeconds(content.duration || "");

        if (views < minViews) return false;
        if (views > maxViews) return false;
        if (subs < minSubs) return false;
        if (subs > maxSubs) return false;

        if (excludeLive) {
          const lbc = snippet.liveBroadcastContent;
          if (lbc && lbc !== "none") return false;
        }

        if (excludeShorts) {
          if (durationSeconds > 0 && durationSeconds < 60) return false;
        }

        return true;
      });

      const field = sortFieldSelect.value; // "views" | "date" | "subs" | "vph"
      const dir = sortDirection === "asc" ? 1 : -1;

      filtered.sort((a, b) => {
        let ka = 0, kb = 0;
        if (field === "views") {
          ka = Number(a.statistics && a.statistics.viewCount || 0);
          kb = Number(b.statistics && b.statistics.viewCount || 0);
        } else if (field === "date") {
          ka = new Date(a.snippet && a.snippet.publishedAt || 0).getTime();
          kb = new Date(b.snippet && b.snippet.publishedAt || 0).getTime();
        } else if (field === "subs") {
          ka = Number(a._subscriberCount || 0);
          kb = Number(b._subscriberCount || 0);
        } else if (field === "vph") {
          ka = calcVph(a);
          kb = calcVph(b);
        }
        return (kb - ka) * dir;
      });

      currentVideos = filtered;
      renderVideos();
      computeStats();
      resultsInfoEl.textContent =
        filtered.length + "개의 영상 (필터·정렬 적용됨)";
      updateSummaryCount(filtered.length);
      exportCsvBtn.disabled = !filtered.length;
    }

    // ------ API 호출 메인 함수 ------
    async function fetchVideos() {
      const apiKey = apiKeyInput.value.trim();
      const channelIdRaw = channelIdInput.value.trim();
      const keywordRaw = keywordInput.value.trim();
      const order = orderSelect.value;
      const maxResults = Math.min(
        150,
        Math.max(1, parseInt(maxResultsInput.value || "50", 10))
      );
      const daysRange = Math.max(0, parseInt(daysRangeInput.value || "0", 10));

      if (!apiKey) {
        setStatus("API 키를 입력해주세요.", "error");
        return;
      }

      if (currentMode === "channel" && !channelIdRaw) {
        setStatus("채널 입력을 해주세요. (URL/ID/@/이름)", "error");
        return;
      }

      if (currentMode === "keyword" && !keywordRaw) {
        setStatus("키워드 또는 영상 URL을 입력해주세요.", "error");
        return;
      }

      fetchBtn.disabled = true;
      exportCsvBtn.disabled = true;
      setStatus("YouTube에서 데이터를 불러오는 중입니다...", "info", true);
      resultsListEl.innerHTML = "";
      resultsInfoEl.textContent = "불러오는 중...";
      allVideos = [];
      currentVideos = [];
      updateSummaryCount(0);
      resetStats();
      setAnalysisText("");

      try {
        // ----- 키워드 모드: 영상 링크 처리 우선 -----
        if (currentMode === "keyword") {
          const vidFromLink = extractVideoIdFromInput(keywordRaw);
          if (vidFromLink) {
            const videosBase = "https://www.googleapis.com/youtube/v3/videos";
            const videosParams = new URLSearchParams({
              key: apiKey,
              part: "snippet,contentDetails,statistics",
              id: vidFromLink,
            });
            const url = videosBase + "?" + videosParams.toString();
            const res = await fetch(url);
            if (!res.ok) {
              const errData = await res.json().catch(() => ({}));
              const msg =
                errData.error && errData.error.message
                  ? errData.error.message
                  : "영상 상세 조회 실패 (HTTP " + res.status + ")";
              throw new Error(msg);
            }
            const data = await res.json();
            const items = data.items || [];
            if (!items.length) {
              throw new Error("해당 영상 ID/URL로 영상을 찾을 수 없습니다.");
            }

            try {
              await attachChannelSubs(apiKey, items);
            } catch (e) {
              console.warn("채널 구독자 정보 조회 실패(단일 영상)", e);
            }

            allVideos = items;
            applyFiltersAndSort();
            setStatus("단일 영상 분석 완료.", "info");
            return;
          }
        }

        // ----- 채널 모드: 채널 입력 해석 -----
        let channelIdForSearch = null;
        let channelCandidates = null;

        if (currentMode === "channel") {
          const resolution = await resolveChannelFromInput(apiKey, channelIdRaw);

          if (resolution.type === "id") {
            channelIdForSearch = resolution.id;
          } else if (resolution.type === "multi") {
            channelCandidates = resolution.channels || [];
            if (!channelCandidates.length) {
              throw new Error("채널 후보를 찾지 못했습니다.");
            }
            renderChannelCandidates(channelCandidates);
            setStatus(
              "채널 이름 '" +
                channelIdRaw +
                "'로 " +
                channelCandidates.length +
                "개 채널을 찾았습니다. 채널을 클릭하면 영상 분석을 진행합니다.",
              "info"
            );
            resultsInfoEl.textContent = channelCandidates.length + "개 채널 후보";
            fetchBtn.disabled = false;
            exportCsvBtn.disabled = true;
            return;
          } else {
            throw new Error("채널을 찾을 수 없습니다.");
          }
        }

        // ----- 공통: 검색 API (video 검색) -----
        const searchBase = "https://www.googleapis.com/youtube/v3/search";
        const searchParams = new URLSearchParams({
          key: apiKey,
          part: "snippet",
          maxResults: "50",
          type: "video",
          order: order,
        });

        if (currentMode === "channel") {
          searchParams.set("channelId", channelIdForSearch);
        } else {
          searchParams.set("q", keywordRaw);
        }

        if (daysRange > 0) {
          const now = new Date();
          const past = new Date(now.getTime() - daysRange * 24 * 60 * 60 * 1000);
          searchParams.set("publishedAfter", past.toISOString());
        }

        let fetched = 0;
        let nextPageToken = null;
        const videoIds = [];

        do {
          if (nextPageToken) {
            searchParams.set("pageToken", nextPageToken);
          } else {
            searchParams.delete("pageToken");
          }

          const url = searchBase + "?" + searchParams.toString();
          const res = await fetch(url);
          if (!res.ok) {
            const errData = await res.json().catch(() => ({}));
            const msg = errData.error && errData.error.message
              ? errData.error.message
              : "검색 API 요청 실패 (HTTP " + res.status + ")";
            throw new Error(msg);
          }
          const data = await res.json();
          const items = data.items || [];
          items.forEach((item) => {
            if (item.id && item.id.videoId) {
              videoIds.push(item.id.videoId);
            }
          });
          fetched += items.length;
          nextPageToken = data.nextPageToken && fetched < maxResults ? data.nextPageToken : null;
        } while (nextPageToken && fetched < maxResults);

        if (videoIds.length === 0) {
          setStatus("조건에 맞는 영상이 없습니다.", "info");
          resultsInfoEl.textContent = "0개의 영상";
          resultsListEl.innerHTML =
            '<div class="empty-state">조건에 맞는 영상이 없거나, 검색 조건이 너무 제한적일 수 있습니다.</div>';
          return;
        }

        const detailedVideos = [];
        const videosBase = "https://www.googleapis.com/youtube/v3/videos";
        const uniqueIds = Array.from(new Set(videoIds)).slice(0, maxResults);

        for (let i = 0; i < uniqueIds.length; i += 50) {
          const batchIds = uniqueIds.slice(i, i + 50);
          const videosParams = new URLSearchParams({
            key: apiKey,
            part: "snippet,contentDetails,statistics",
            id: batchIds.join(","),
          });
          const url = videosBase + "?" + videosParams.toString();
          const res = await fetch(url);
          if (!res.ok) {
            const errData = await res.json().catch(() => ({}));
            const msg =
              errData.error && errData.error.message
                ? errData.error.message
                : "videos.list API 요청 실패 (HTTP " + res.status + ")";
            throw new Error(msg);
          }
          const data = await res.json();
          (data.items || []).forEach((item) => detailedVideos.push(item));
        }

        try {
          await attachChannelSubs(apiKey, detailedVideos);
        } catch (e) {
          console.warn("채널 구독자 정보 조회 실패", e);
        }

        detailedVideos.sort((a, b) => {
          const da = new Date(a.snippet && a.snippet.publishedAt || 0).getTime();
          const db = new Date(b.snippet && b.snippet.publishedAt || 0).getTime();
          return db - da;
        });

        allVideos = detailedVideos;
        applyFiltersAndSort();
        setStatus(
          "불러오기 완료. 총 " + allVideos.length + "개 영상 로드됨 (필터·정렬 후 " + currentVideos.length + "개).",
          "info"
        );
      } catch (err) {
        console.error(err);
        setStatus("오류: " + err.message, "error");
        resultsInfoEl.textContent = "에러 발생";
        resultsListEl.innerHTML =
          '<div class="empty-state">요청 중 오류가 발생했습니다. API 키, 쿼터, 입력값(채널/키워드/URL)을 다시 확인해주세요.</div>';
      } finally {
        fetchBtn.disabled = false;
      }
    }

    // ------ 채널 후보 렌더링 ------
    function renderChannelCandidates(channels) {
      allVideos = [];
      currentVideos = [];
      resetStats();
      resultsListEl.innerHTML = "";
      if (!channels || !channels.length) {
        resultsListEl.innerHTML =
          '<div class="empty-state">표시할 채널 후보가 없습니다.</div>';
        return;
      }

      const fr = document.createDocumentFragment();
      channels.forEach((ch) => {
        const card = document.createElement("article");
        card.className = "channel-card";

        const thumbDiv = document.createElement("div");
        thumbDiv.className = "channel-thumb";
        if (ch.thumbnail && ch.thumbnail.url) {
          const img = document.createElement("img");
          img.src = ch.thumbnail.url;
          img.alt = ch.title;
          thumbDiv.appendChild(img);
        } else {
          thumbDiv.innerHTML =
            '<div style="width:64px;height:64px;border-radius:50%;border:1px solid #4b5563;display:flex;align-items:center;justify-content:center;font-size:0.8rem;color:#6b7280;">No</div>';
        }

        const bodyDiv = document.createElement("div");
        bodyDiv.className = "channel-body";
        const titleDiv = document.createElement("div");
        titleDiv.className = "channel-title";
        titleDiv.textContent = ch.title;

        const idDiv = document.createElement("div");
        idDiv.className = "channel-id";
        idDiv.textContent = "ID: " + ch.id;

        const hintDiv = document.createElement("div");
        hintDiv.className = "channel-hint";
        hintDiv.textContent = "이 채널을 클릭하면 해당 채널 영상들을 분석합니다.";

        bodyDiv.appendChild(titleDiv);
        bodyDiv.appendChild(idDiv);
        bodyDiv.appendChild(hintDiv);

        card.appendChild(thumbDiv);
        card.appendChild(bodyDiv);

        card.addEventListener("click", () => {
          channelIdInput.value = ch.id;
          fetchVideos();
        });

        fr.appendChild(card);
      });

      resultsListEl.appendChild(fr);
    }

    // ------ 결과 렌더링 (분석 버튼 + 색상 적용) ------
    function renderVideos() {
      if (!currentVideos.length) {
        resultsListEl.innerHTML =
          '<div class="empty-state">표시할 영상이 없습니다. (필터 조건을 조정해보세요.)</div>';
     


::contentReference[oaicite:0]{index=0}
